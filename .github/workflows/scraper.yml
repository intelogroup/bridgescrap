name: Bridge Assignments Production Monitor

on:
  schedule:
    - cron: '*/10 * * * *'  # Trigger every 10 minutes, actual run time will be randomized
  workflow_dispatch:  # Allow manual trigger

env:
  PRODUCTION: true
  NOTIFICATION_EMAIL: ${{ secrets.EMAIL_USER }}

jobs:
  check-assignments:
    runs-on: ubuntu-24.04
    
    # Add concurrency to prevent overlapping runs
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Install Chrome
      run: |
        sudo apt-get update
        sudo apt-get install -y chromium-browser
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Set up logging
      run: |
        mkdir -p bridge_logs
        chmod 777 bridge_logs
        cat > logging_config.py << 'EOL'
        import logging
        import os

        # Ensure the logs directory exists
        os.makedirs('bridge_logs', exist_ok=True)

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(os.path.join('bridge_logs', 'app.log')),
                logging.StreamHandler()
            ]
        )
        EOL
        
    - name: Set up environment variables
      env:
        BRIDGE_USERNAME: ${{ secrets.BRIDGE_USERNAME }}
        BRIDGE_PASSWORD: ${{ secrets.BRIDGE_PASSWORD }}
        EMAIL_USER: ${{ secrets.EMAIL_USER }}
        EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
      run: |
        echo "BRIDGE_USERNAME=${BRIDGE_USERNAME}" > .env
        echo "BRIDGE_PASSWORD=${BRIDGE_PASSWORD}" >> .env
        echo "EMAIL_USER=${EMAIL_USER}" >> .env
        echo "EMAIL_PASSWORD=${EMAIL_PASSWORD}" >> .env
        
    - name: Create data directory
      run: mkdir -p data

    - name: Check for maintenance window
      id: maintenance
      run: |
        # Skip during maintenance hours (e.g., 3-4 AM UTC)
        HOUR=$(date +%H)
        if [ "$HOUR" == "03" ]; then
          echo "In maintenance window, skipping run"
          echo "should_run=false" >> $GITHUB_OUTPUT
        else
          echo "should_run=true" >> $GITHUB_OUTPUT
        fi

    - name: Download previous runtime
      id: download
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: last-runtime
        path: .

    - name: Log runtime status
      run: |
        echo "Checking for last runtime file..."
        if [ -f "last_runtime.txt" ]; then
          echo "Found last_runtime.txt:"
          cat last_runtime.txt
        else
          echo "No previous runtime file found (this is normal for first run or after expiration)"
        fi

    - name: Random interval check
      id: random_check
      if: steps.maintenance.outputs.should_run == 'true'
      run: |
        # Initialize LAST_RUN and target run time
        LAST_RUN=0
        TARGET_RUN=0
        if [ -f "last_runtime.txt" ]; then
          while IFS= read -r line || [ -n "$line" ]; do
            if [[ $line == LAST_RUN=* ]]; then
              LAST_RUN=${line#LAST_RUN=}
            elif [[ $line == TARGET_RUN=* ]]; then
              TARGET_RUN=${line#TARGET_RUN=}
            fi
          done < "last_runtime.txt"
        fi
        
        # Get current time
        CURRENT_TIME=$(date +%s)
        
        # If we don't have a target run time or we've passed it, generate a new one
        if [ "$TARGET_RUN" -eq 0 ] || [ "$CURRENT_TIME" -ge "$TARGET_RUN" ]; then
          # Ensure at least 10 minutes have passed since last run
          MIN_WAIT=$((10 * 60))  # 10 minutes in seconds
          if [ "$LAST_RUN" -ne 0 ] && [ "$((CURRENT_TIME - LAST_RUN))" -lt "$MIN_WAIT" ]; then
            echo "Not enough time has passed since last run"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Generate new random target time between 10-40 minutes from last run
          # If no last run, use current time as base
          BASE_TIME=$LAST_RUN
          if [ "$BASE_TIME" -eq 0 ]; then
            BASE_TIME=$CURRENT_TIME
          fi
          
          # Generate random seconds between 600 (10 min) and 2400 (40 min)
          RANDOM_SECONDS=$(python -c "import random; print(random.randint(600, 2400))")
          TARGET_RUN=$((BASE_TIME + RANDOM_SECONDS))
          
          # If we've passed the target time, run now
          if [ "$CURRENT_TIME" -ge "$TARGET_RUN" ]; then
            echo "Running now and setting new target"
            echo "LAST_RUN=$CURRENT_TIME" > last_runtime.txt
            # Generate next target time
            RANDOM_SECONDS=$(python -c "import random; print(random.randint(600, 2400))")
            NEW_TARGET=$((CURRENT_TIME + RANDOM_SECONDS))
            echo "TARGET_RUN=$NEW_TARGET" >> last_runtime.txt
            echo "should_run=true" >> $GITHUB_OUTPUT
          else
            echo "New target time set for: $(date -d @${TARGET_RUN})"
            echo "LAST_RUN=$LAST_RUN" > last_runtime.txt
            echo "TARGET_RUN=$TARGET_RUN" >> last_runtime.txt
            echo "should_run=false" >> $GITHUB_OUTPUT
          fi
        else
          # We have a future target time
          echo "Waiting for target time: $(date -d @${TARGET_RUN})"
          echo "should_run=false" >> $GITHUB_OUTPUT
        fi

    - name: Run assignment checker
      id: checker
      if: steps.random_check.outputs.should_run == 'true'
      env:
        PYTHONUNBUFFERED: 1
      run: |
        # Import logging configuration
        python logging_config.py
        
        # Run with timeout and proper error handling
        timeout 5m python -c "
        import logging
        import sys
        import traceback
        try:
            import main
            main.main()
        except Exception as e:
            logging.error(f'Error running main: {str(e)}')
            logging.error(traceback.format_exc())
            sys.exit(1)
        "
      continue-on-error: true

    - name: Upload runtime
      if: steps.random_check.outputs.should_run == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: last-runtime
        path: last_runtime.txt
        retention-days: 1
        
    - name: Check run status
      if: steps.random_check.outputs.should_run == 'true'
      run: |
        if [ "${{ steps.checker.outcome }}" == "failure" ]; then
          echo "::error::Assignment checker failed to run"
          echo "SCRIPT_FAILED=true" >> $GITHUB_ENV
        fi
      
    - name: Prepare logs directory
      run: |
        echo "Ensuring bridge_logs directory exists and has content..."
        mkdir -p bridge_logs
        echo "Workflow run: ${{ github.run_number }}" > bridge_logs/workflow.log
        echo "Run time: $(date)" >> bridge_logs/workflow.log
        echo "Target run time: $(cat last_runtime.txt 2>/dev/null || echo 'No target time set yet')" >> bridge_logs/workflow.log

    - name: Upload logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: bridge-logs-${{ github.run_number }}
        path: bridge_logs/
        retention-days: 30
        compression-level: 9
        overwrite: true
        
    - name: Upload assignments
      if: steps.random_check.outputs.should_run == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: assignments-${{ github.run_number }}
        path: |
          assignments.txt
          Previous_assignments.txt
        retention-days: 90
        compression-level: 9
        overwrite: true

    - name: Notify on failure
      if: env.SCRIPT_FAILED == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const { repo, owner } = context.repo;
          const run_id = context.runId;
          
          const message = `
          ðŸš¨ Bridge Assignment Checker Failed
          
          Workflow: ${context.workflow}
          Run: ${run_id}
          
          Check the logs at:
          https://github.com/${owner}/${repo}/actions/runs/${run_id}
          `;
          
          github.rest.issues.create({
            owner,
            repo,
            title: `Assignment Checker Failed - ${new Date().toISOString()}`,
            body: message,
            labels: ['bug', 'production']
          });

    - name: Update status
      if: always()
      run: |
        echo "Last run: $(date)" > status.txt
        echo "Status: ${{ steps.checker.outcome }}" >> status.txt
        echo "Run number: ${{ github.run_number }}" >> status.txt
        echo "Next run: Not before $(date -d "@$(($(date +%s) + 600))")" >> status.txt

    - name: Save status
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: status
        path: status.txt
        retention-days: 7
        overwrite: true
