name: Bridge Assignments Production Monitor

on:
  schedule:
    - cron: '*/10 * * * *'  # Trigger every 10 minutes, actual run time will be randomized
  workflow_dispatch:  # Allow manual trigger

env:
  PRODUCTION: true
  NOTIFICATION_EMAIL: ${{ secrets.EMAIL_USER }}

jobs:
  check-assignments:
    runs-on: ubuntu-24.04
    
    # Add concurrency to prevent overlapping runs
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Install Chrome
      run: |
        sudo apt-get update
        sudo apt-get install -y chromium-browser
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Set up logging
      run: |
        mkdir -p bridge_logs
        chmod 777 bridge_logs
        cat > logging_config.py << 'EOL'
        import logging
        import os

        # Ensure the logs directory exists
        os.makedirs('bridge_logs', exist_ok=True)

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(os.path.join('bridge_logs', 'app.log')),
                logging.StreamHandler()
            ]
        )
        EOL
        
    - name: Set up environment variables
      env:
        BRIDGE_USERNAME: ${{ secrets.BRIDGE_USERNAME }}
        BRIDGE_PASSWORD: ${{ secrets.BRIDGE_PASSWORD }}
        EMAIL_USER: ${{ secrets.EMAIL_USER }}
        EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
      run: |
        echo "BRIDGE_USERNAME=${BRIDGE_USERNAME}" > .env
        echo "BRIDGE_PASSWORD=${BRIDGE_PASSWORD}" >> .env
        echo "EMAIL_USER=${EMAIL_USER}" >> .env
        echo "EMAIL_PASSWORD=${EMAIL_PASSWORD}" >> .env
        
    - name: Create data directory
      run: mkdir -p data

    - name: Check for maintenance window
      id: maintenance
      run: |
        # Skip during maintenance hours (e.g., 3-4 AM UTC)
        HOUR=$(date +%H)
        if [ "$HOUR" == "03" ]; then
          echo "In maintenance window, skipping run"
          echo "should_run=false" >> $GITHUB_OUTPUT
        else
          echo "should_run=true" >> $GITHUB_OUTPUT
        fi

    - name: Download previous runtime
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: last-runtime
        path: .

    - name: Random interval check
      id: random_check
      if: steps.maintenance.outputs.should_run == 'true'
      run: |
        # Initialize LAST_RUN
        LAST_RUN=0
        if [ -f "last_runtime.txt" ]; then
          LAST_RUN=$(cat last_runtime.txt | tr -d '\r\n')
        fi
        
        # Get current time
        CURRENT_TIME=$(date +%s)
        
        # Calculate time difference
        TIME_DIFF=0
        if [ -n "$LAST_RUN" ]; then
          TIME_DIFF=$((CURRENT_TIME - LAST_RUN))
        fi
        
        # Set intervals
        MIN_INTERVAL=$((10 * 60))  # 10 minutes in seconds
        MAX_INTERVAL=$((40 * 60))  # 40 minutes in seconds
        
        # Check if enough time has passed
        if [ "$TIME_DIFF" -lt "$MIN_INTERVAL" ]; then
          echo "Not enough time has passed since last run (${TIME_DIFF}s < ${MIN_INTERVAL}s)"
          echo "should_run=false" >> $GITHUB_OUTPUT
        else
          # Generate random interval between 10 and 40 minutes
          RANDOM_MINUTES=$(python -c "import random; print(random.randint(10, 40))")
          NEXT_INTERVAL=$((RANDOM_MINUTES * 60))
          
          if [ "$TIME_DIFF" -ge "$NEXT_INTERVAL" ]; then
            echo "Time for next run (${TIME_DIFF}s >= ${NEXT_INTERVAL}s). Setting new timestamp."
            echo "$CURRENT_TIME" > last_runtime.txt
            echo "should_run=true" >> $GITHUB_OUTPUT
          else
            echo "Waiting for next interval (${TIME_DIFF}s < ${NEXT_INTERVAL}s)"
            echo "should_run=false" >> $GITHUB_OUTPUT
          fi
        fi

    - name: Run assignment checker
      id: checker
      if: steps.random_check.outputs.should_run == 'true'
      env:
        PYTHONUNBUFFERED: 1
      run: |
        # Import logging configuration
        python logging_config.py
        
        # Run with timeout and proper error handling
        timeout 5m python -c "
        import logging
        import sys
        import traceback
        try:
            import main
            main.main()
        except Exception as e:
            logging.error(f'Error running main: {str(e)}')
            logging.error(traceback.format_exc())
            sys.exit(1)
        "
      continue-on-error: true

    - name: Upload runtime
      if: steps.random_check.outputs.should_run == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: last-runtime
        path: last_runtime.txt
        retention-days: 1
        
    - name: Check run status
      if: steps.random_check.outputs.should_run == 'true'
      run: |
        if [ "${{ steps.checker.outcome }}" == "failure" ]; then
          echo "::error::Assignment checker failed to run"
          echo "SCRIPT_FAILED=true" >> $GITHUB_ENV
        fi
      
    - name: Upload logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: bridge-logs-${{ github.run_number }}
        path: bridge_logs/
        retention-days: 30
        compression-level: 9
        overwrite: true
        
    - name: Upload assignments
      if: steps.random_check.outputs.should_run == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: assignments-${{ github.run_number }}
        path: |
          assignments.txt
          Previous_assignments.txt
        retention-days: 90
        compression-level: 9
        overwrite: true

    - name: Notify on failure
      if: env.SCRIPT_FAILED == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const { repo, owner } = context.repo;
          const run_id = context.runId;
          
          const message = `
          ðŸš¨ Bridge Assignment Checker Failed
          
          Workflow: ${context.workflow}
          Run: ${run_id}
          
          Check the logs at:
          https://github.com/${owner}/${repo}/actions/runs/${run_id}
          `;
          
          github.rest.issues.create({
            owner,
            repo,
            title: `Assignment Checker Failed - ${new Date().toISOString()}`,
            body: message,
            labels: ['bug', 'production']
          });

    - name: Update status
      if: always()
      run: |
        echo "Last run: $(date)" > status.txt
        echo "Status: ${{ steps.checker.outcome }}" >> status.txt
        echo "Run number: ${{ github.run_number }}" >> status.txt
        echo "Next run: Not before $(date -d "@$(($(date +%s) + 600))")" >> status.txt

    - name: Save status
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: status
        path: status.txt
        retention-days: 7
        overwrite: true
