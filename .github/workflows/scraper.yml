name: Bridge Assignments Production Monitor

on:
  schedule:
    - cron: '*/10 * * * *'  # Trigger every 10 minutes, actual run time will be randomized
  workflow_dispatch:  # Allow manual trigger

env:
  PRODUCTION: true
  NOTIFICATION_EMAIL: ${{ secrets.EMAIL_USER }}

jobs:
  check-assignments:
    runs-on: ubuntu-24.04
    
    # Add concurrency to prevent overlapping runs
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
    
    - name: Install GitHub CLI
      run: |
        type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
        && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
        && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
        && sudo apt update \
        && sudo apt install gh -y
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Install Chrome
      run: |
        sudo apt-get update
        sudo apt-get install -y chromium-browser
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Set up logging
      run: |
        mkdir -p bridge_logs
        chmod 777 bridge_logs
        cat > logging_config.py << 'EOL'
        import logging
        import os

        # Ensure the logs directory exists
        os.makedirs('bridge_logs', exist_ok=True)

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(os.path.join('bridge_logs', 'app.log')),
                logging.StreamHandler()
            ]
        )
        EOL
        
    - name: Set up environment variables
      env:
        BRIDGE_USERNAME: ${{ secrets.BRIDGE_USERNAME }}
        BRIDGE_PASSWORD: ${{ secrets.BRIDGE_PASSWORD }}
        EMAIL_USER: ${{ secrets.EMAIL_USER }}
        EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
      run: |
        echo "BRIDGE_USERNAME=${BRIDGE_USERNAME}" > .env
        echo "BRIDGE_PASSWORD=${BRIDGE_PASSWORD}" >> .env
        echo "EMAIL_USER=${EMAIL_USER}" >> .env
        echo "EMAIL_PASSWORD=${EMAIL_PASSWORD}" >> .env
        
    - name: Create data directory
      run: mkdir -p data

    - name: Check for maintenance window
      id: maintenance
      run: |
        # Skip during maintenance hours (e.g., 3-4 AM UTC)
        HOUR=$(date +%H)
        if [ "$HOUR" == "03" ]; then
          echo "In maintenance window, skipping run"
          echo "should_run=false" >> $GITHUB_OUTPUT
        else
          echo "should_run=true" >> $GITHUB_OUTPUT
        fi

    - name: Load or initialize runtime state
      id: runtime_init
      run: |
        echo "::notice::Managing runtime state"
        STATE_FILE=".github/state/runtime_state.json"
        
        if [ -f "$STATE_FILE" ]; then
          echo "::notice::Loading existing state file"
          cat "$STATE_FILE"
        else
          echo "::notice::Creating initial state file"
          CURRENT_TIME=$(date +%s)
          RANDOM_SECONDS=$(python -c "import random; print(random.randint(600, 2400))")
          TARGET_TIME=$((CURRENT_TIME + RANDOM_SECONDS))
          
          # Create state file with JSON format for better structure
          jq -n \
            --arg time "$CURRENT_TIME" \
            --arg target "$TARGET_TIME" \
            --arg run "${{ github.run_number }}" \
            --arg update "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" \
            '{
              last_run: ($time|tonumber),
              target_run: ($target|tonumber),
              init_time: ($time|tonumber),
              last_workflow_run: ($run|tonumber),
              last_update: $update,
              history: []
            }' > "$STATE_FILE"
          
          # Also create the runtime.txt for backward compatibility
          echo "LAST_RUN=$CURRENT_TIME" > last_runtime.txt
          echo "TARGET_RUN=$TARGET_TIME" >> last_runtime.txt
        fi
        
        # Parse state file for use in workflow
        if [ -f "$STATE_FILE" ]; then
          LAST_RUN=$(jq -r '.last_run' "$STATE_FILE")
          TARGET_RUN=$(jq -r '.target_run' "$STATE_FILE")
          echo "LAST_RUN=$LAST_RUN" > last_runtime.txt
          echo "TARGET_RUN=$TARGET_RUN" >> last_runtime.txt
        fi

    - name: Update state file
      if: steps.random_check.outputs.should_run == 'true'
      run: |
        STATE_FILE=".github/state/runtime_state.json"
        CURRENT_TIME=$(date +%s)
        RANDOM_SECONDS=$(python -c "import random; print(random.randint(600, 2400))")
        NEW_TARGET=$((CURRENT_TIME + RANDOM_SECONDS))
        
        # Update state file
        TMP_FILE=$(mktemp)
        jq --arg time "$CURRENT_TIME" \
           --arg target "$NEW_TARGET" \
           --arg update "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" \
           --arg run "${{ github.run_number }}" \
           '.last_run = ($time|tonumber) |
            .target_run = ($target|tonumber) |
            .last_update = $update |
            .last_workflow_run = ($run|tonumber) |
            .history += [{
              "run_time": ($time|tonumber),
              "workflow_run": ($run|tonumber),
              "target_time": ($target|tonumber)
            }] |
            if (.history|length > 100) then
              .history = .history[1:]
            else
              .
            end' \
            "$STATE_FILE" > "$TMP_FILE" && mv "$TMP_FILE" "$STATE_FILE"
        
        echo "Updated state file:"
        cat "$STATE_FILE"

    - name: Commit state changes
      if: steps.random_check.outputs.should_run == 'true'
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add .github/state/runtime_state.json
        git commit -m "Update runtime state [skip ci]" || echo "No changes to commit"
        git push

    - name: Random interval check
      id: random_check
      if: steps.maintenance.outputs.should_run == 'true'
      run: |
        # Initialize LAST_RUN and target run time
        LAST_RUN=0
        TARGET_RUN=0
        if [ -f "last_runtime.txt" ]; then
          while IFS= read -r line || [ -n "$line" ]; do
            if [[ $line == LAST_RUN=* ]]; then
              LAST_RUN=${line#LAST_RUN=}
            elif [[ $line == TARGET_RUN=* ]]; then
              TARGET_RUN=${line#TARGET_RUN=}
            fi
          done < "last_runtime.txt"
        fi
        
        # Get current time
        CURRENT_TIME=$(date +%s)
        
        # If we don't have a target run time or we've passed it, generate a new one
        if [ "$TARGET_RUN" -eq 0 ] || [ "$CURRENT_TIME" -ge "$TARGET_RUN" ]; then
          # Ensure at least 10 minutes have passed since last run
          MIN_WAIT=$((10 * 60))  # 10 minutes in seconds
          if [ "$LAST_RUN" -ne 0 ] && [ "$((CURRENT_TIME - LAST_RUN))" -lt "$MIN_WAIT" ]; then
            echo "Not enough time has passed since last run"
            echo "should_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Generate new random target time between 10-40 minutes from last run
          # If no last run, use current time as base
          BASE_TIME=$LAST_RUN
          if [ "$BASE_TIME" -eq 0 ]; then
            BASE_TIME=$CURRENT_TIME
          fi
          
          # Generate random seconds between 600 (10 min) and 2400 (40 min)
          RANDOM_SECONDS=$(python -c "import random; print(random.randint(600, 2400))")
          TARGET_RUN=$((BASE_TIME + RANDOM_SECONDS))
          
          # If we've passed the target time, run now
          if [ "$CURRENT_TIME" -ge "$TARGET_RUN" ]; then
            echo "Running now and setting new target"
            echo "LAST_RUN=$CURRENT_TIME" > last_runtime.txt
            # Generate next target time
            RANDOM_SECONDS=$(python -c "import random; print(random.randint(600, 2400))")
            NEW_TARGET=$((CURRENT_TIME + RANDOM_SECONDS))
            echo "TARGET_RUN=$NEW_TARGET" >> last_runtime.txt
            echo "should_run=true" >> $GITHUB_OUTPUT
          else
            echo "New target time set for: $(date -d @${TARGET_RUN})"
            echo "LAST_RUN=$LAST_RUN" > last_runtime.txt
            echo "TARGET_RUN=$TARGET_RUN" >> last_runtime.txt
            echo "should_run=false" >> $GITHUB_OUTPUT
          fi
        else
          # We have a future target time
          echo "Waiting for target time: $(date -d @${TARGET_RUN})"
          echo "should_run=false" >> $GITHUB_OUTPUT
        fi

    - name: Run assignment checker
      id: checker
      if: steps.random_check.outputs.should_run == 'true'
      env:
        PYTHONUNBUFFERED: 1
      run: |
        # Import logging configuration
        python logging_config.py
        
        # Run with timeout and proper error handling
        timeout 5m python -c "
        import logging
        import sys
        import traceback
        try:
            import main
            main.main()
        except Exception as e:
            logging.error(f'Error running main: {str(e)}')
            logging.error(traceback.format_exc())
            sys.exit(1)
        "
      continue-on-error: true

    - name: Upload runtime
      if: steps.random_check.outputs.should_run == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: last-runtime
        path: last_runtime.txt
        retention-days: 1
        
    - name: Check run status
      if: steps.random_check.outputs.should_run == 'true'
      run: |
        if [ "${{ steps.checker.outcome }}" == "failure" ]; then
          echo "::error::Assignment checker failed to run"
          echo "SCRIPT_FAILED=true" >> $GITHUB_ENV
        fi
      
    - name: Initialize logging
      run: |
        echo "::notice::Setting up logging system"
        mkdir -p bridge_logs
        {
          echo "=== Workflow Run Details ==="
          echo "Run Number: ${{ github.run_number }}"
          echo "Run Time: $(date)"
          echo "Run ID: ${{ github.run_id }}"
          echo ""
          echo "=== Runtime Configuration ==="
          if [ -f "last_runtime.txt" ]; then
            cat last_runtime.txt
          else
            echo "No runtime configuration found"
          fi
          echo ""
          echo "=== Environment ==="
          echo "Python Version: $(python --version)"
          echo "Node Version: $(node --version)"
          echo "Working Directory: $(pwd)"
        } > bridge_logs/workflow.log
        
        echo "Created log file:"
        cat bridge_logs/workflow.log

    - name: Upload logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: bridge-logs-${{ github.run_number }}
        path: bridge_logs/
        retention-days: 30
        compression-level: 9
        overwrite: true
        
    - name: Upload assignments
      if: steps.random_check.outputs.should_run == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: assignments-${{ github.run_number }}
        path: |
          assignments.txt
          Previous_assignments.txt
        retention-days: 90
        compression-level: 9
        overwrite: true

    - name: Notify on failure
      if: env.SCRIPT_FAILED == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const { repo, owner } = context.repo;
          const run_id = context.runId;
          
          const message = `
          ðŸš¨ Bridge Assignment Checker Failed
          
          Workflow: ${context.workflow}
          Run: ${run_id}
          
          Check the logs at:
          https://github.com/${owner}/${repo}/actions/runs/${run_id}
          `;
          
          github.rest.issues.create({
            owner,
            repo,
            title: `Assignment Checker Failed - ${new Date().toISOString()}`,
            body: message,
            labels: ['bug', 'production']
          });

    - name: Update status
      if: always()
      run: |
        echo "Last run: $(date)" > status.txt
        echo "Status: ${{ steps.checker.outcome }}" >> status.txt
        echo "Run number: ${{ github.run_number }}" >> status.txt
        echo "Next run: Not before $(date -d "@$(($(date +%s) + 600))")" >> status.txt

    - name: Save status
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: status
        path: status.txt
        retention-days: 7
        overwrite: true
